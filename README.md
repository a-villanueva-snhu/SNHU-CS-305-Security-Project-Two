**The Final Project for CS 305: Secure REST Service for Artemis Financial**

This project is a Java Spring Boot application refactoring for a fictional client, Artemis Financial. The primary goals were to remediate critical dependency vulnerabilities, implement secure communication protocols, and add a cryptographic hashing feature for data integrity.

Key Features 
Vulnerability Remediation: Upgraded the Spring Boot framework from an insecure version (2.2.4) to a modern, secure version (3.3.3), resolving numerous critical CVEs in core dependencies.

Secure Communication (HTTPS): Configured the application to use the HTTPS protocol with a self-signed TLS certificate, ensuring all data transmitted between the client and server is encrypted.

Cryptographic Hashing: Implemented a /hash REST endpoint that provides a SHA-256 checksum for any given string, allowing for data integrity verification.

Secure Coding Practices: Refactored code to follow best practices, including using a dedicated controller for web logic and implementing secure error logging.

Technologies Used 
Java 17

Spring Boot 3.3.3

Apache Maven

OWASP Dependency-Check for vulnerability scanning

Java Keytool for certificate management

Getting Started
Prerequisites
Java Development Kit (JDK) 17 or newer

Apache Maven

How to Run
Build the application:

mvn clean install

Run the application:

java -jar target/rest-service-0.0.2-SNAPSHOT.jar

The server will start on port 8443.

Test the Hashing Endpoint:
Open a web browser and navigate to the following URL to get the SHA-256 hash of "HelloArtemis":
https://localhost:8443/hash?data=HelloArtemis

(Note: You may need to accept a browser security warning because the TLS certificate is self-signed.)

Project Summary and Reflection
Briefly summarize your client, Artemis Financial, and its software requirements.
The client, Artemis Financial, is a consulting company that develops individualized financial plans. They needed to modernize their public-facing web application. The company's primary issue was the software's security; they required a comprehensive security overhaul to protect sensitive client data, fix known vulnerabilities in the code base, and add a new data verification feature in the form of a checksum to ensure file integrity during transfers.

What did you do well when you found your clientâ€™s software security vulnerabilities?
I believe I did well in the systematic identification and remediation of the vulnerabilities. By using the OWASP dependency-check tool, I produced a data-driven report of specific, actionable flaws rather than guessing. Most importantly, instead of taking a shortcut like suppressing the warnings, I addressed the root cause by updating the entire framework.

It is critically important to code securely because a single vulnerability can lead to a data breach, compromising sensitive financial information. For Artemis Financial, such a breach would result in a catastrophic loss of customer trust, significant legal and financial penalties, and damage to their reputation. Software security adds immense value by protecting the company's assets, ensuring business continuity, and building a foundation of trust with its clients.

Which part of the vulnerability assessment was challenging or helpful to you?
The most helpful part was the clear, itemized report generated by the dependency-check tool. It transformed the abstract goal of "improving security" into a concrete to-do list, identifying the exact libraries and versions that were vulnerable. The most challenging part was navigating the initial build failures after the first attempt to update dependencies. It required research to understand that the issue was a cascade of version incompatibilities and that the correct solution was to update the parent POM and the Java version, which then managed all the transitive dependencies correctly.

How did you increase layers of security?
I increased security by applying a defense-in-depth strategy, adding multiple, overlapping security controls:

Foundation Hardening: The first layer was patching the application's foundation by upgrading the Spring Boot framework, eliminating a wide range of known vulnerabilities.

Data Integrity: The second layer was adding the SHA-256 hashing endpoint. This gives the client a tool to verify that data has not been tampered with.

Data Confidentiality: The third layer was implementing HTTPS, which encrypts all data in transit, protecting it from eavesdropping.

In the future, I would use a combination of SAST (Static Application Security Testing) tools like dependency-check early in the development cycle, DAST (Dynamic Application Security Testing) tools like OWASP ZAP to test the running application for runtime vulnerabilities, and manual code reviews to catch logic flaws that automated tools might miss.

How did you make certain the code and software application were functional and secure?
Functional Verification: I ran the project's built-in Maven test suite (mvn test) to ensure all existing functionality still passed after the refactoring. I then performed manual testing by starting the server and hitting the new /hash endpoint with various inputs to confirm it produced the correct output.

Security Verification: After refactoring the code, I re-ran the dependency-check scan. I then compared the "before" and "after" reports to verify that the critical vulnerabilities I initially identified were no longer present. This check ensured that my changes fixed the problems without introducing new, known dependency vulnerabilities.

What resources, tools, or coding practices did you use that might be helpful in future assignments or tasks?
Tools: OWASP Dependency-Check is an incredibly powerful tool that I will use in all future projects to automate the detection of vulnerable libraries.

Resources: The Maven Central Repository was an essential resource for researching dependency versions and understanding their relationships.

Coding Practices: The principle of Separation of Concerns (creating a dedicated HashController instead of cluttering the main application class) is a practice I will continue to use to keep code clean and maintainable.

What might you show future employers from this assignment?
From this assignment, I would show a future employer three key items:

The "before" and "after" dependency-check reports: This provides concrete, measurable proof of my ability to identify and remediate critical security vulnerabilities.

The HashController.java file: This serves as a concise code sample demonstrating my ability to write clean, secure, and well-documented code that implements a new feature.

This README file: It showcases my ability to clearly document a project's architecture, features, and security posture, and to reflect on the development process.
